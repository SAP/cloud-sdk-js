---
id: use-typed-odata-client-for-js
title: Use the type-safe client to consume OData Services for JS/TS
hide_title: false
hide_table_of_contents: false
sidebar_label: Use the type-safe client to consume OData Services for JS/TS
description: Use SAP Cloud SDK for JavaScript to build and run OData requests in a typesafe way.
keywords:
- sap
- cloud
- sdk
- odata
- JavaScript 
- TypeScript
- consume
author: Charles Dubois
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Build and execute OData Requests with the typed OData client

The typed OData client allows to build type-safe OData requests for a given service.

## Making a request with the generated OData client

Every OData client generated by the SAP Cloud SDK provides request builders and abstractions for entity sets, that we refer to as entities. In order to create a request towards a specific entity set, leverage the fluent API of an entity.

First, import the generated service:

```ts
import { MyEntity } from './outputDir/my-service';
```

Where `outputDir` is the directory you specified when generating the service and `my-service` was the ` directoryName` specified in the `serviceMapping.json` file which is inside your input directory.
On an abstract level, creating a request using the fluent api always follows the same simple structure:

```ts
return MyEntity.requestBuilder()
    .<requestType>(...)
    .<additionalRequestConfiguration>(...)
    .execute(myDestination);
```

- _requestBuilder_ to construct requests for operations.
- _requestType_ can be one of `create`, `getAll`, `getByKey`, `update`, `delete`.
- _additionalRequestConfiguration_ depends on _requestType_:
    - for all of them:
        - `execute` executes the query (cannot be used on `getAll` alone).
        - `withCustomHeaders` passes the API key for example.
        - `withCustomQueryParameters` adds key-value pairs.
        - `build` builds an ODataRequest that holds essential configuration for the service request and executes it.
        - other requests (`url`, `withCustomServicePath`, `relativeUrl`)
    - for `create` only:
        - `asChilOf` specifies the parent of the entity to create.
    - for `create` and `update`:
        - `prepare` builds the payload of the query.
    - for `update` and `delete`:
        - `ignoreVersionIdentifier` instructs the request to force an overwrite of the entity by [sending an 'If-Match: *' header instead of sending the ETag version identifier](#Handling-of-ETags).
    - for `delete` only:
        - `setVersionIdentifier` adds an ETag version identifier in the delete request header.
    - for `getAll`, they are mainly OData query parameters:
        - [`select`](#Select) restricts the response to the given selection of properties in the request. (also used by getByKey)
        - [`filter`](#Filter) Add filter statements to the request.
        - `orderBy`
        - `skip` skips number of entities. Useful for paging.
        - `top` limits number of returned entities.
- _myDestination_ is an URL of the server, it can be declared as
```ts
var myDestination : {url: '<yourURL>'}
```

Below different OData features are documented using the [Business Partner Service](https://api.sap.com/api/API_BUSINESS_PARTNER/resource) on S/4HANA as an example.
<!--The following code snippets assume that an instance of this service is set up:

```ts
constructor(private readonly businessPartnerService: BusinessPartnerService) {}
```

:::tip Structure your code
All of the following code can be organised in service files, e.g., `MyEntity.service.ts`
:::
-->

## OData Features

### Basic CRUD Operations

Create, Read, Update and Delete operations on entities are usually built inside the service class:

```ts
BusinessPartnerAddress.requestBuilder().create(partner);
BusinessPartnerAddress.requestBuilder().getAll();
BusinessPartnerAddress.requestBuilder().getByKey('id');
BusinessPartnerAddress.requestBuilder().update(partner);
BusinessPartnerAddress.requestBuilder().delete();
```

Each of the above statements returns a builder object that allows for specifying certain request parameters, depending on the operation.

<!--Maybe the Query parameters and Request parameters are redundant because already explained previously?-->

The following query parameters and request options are available for these operations:

Query parameters:
- `$select` and `$expand` are available on reading a single or multiple entities
- `$filter`, `$top`, `$skip` and `$orderby` are available only when reading a collection of entities

Request parameters:
- Update and delete operations allow to modify how ETags are handled:
   - By default an ETag is send if one is present on the entity being modified.
   - `ignoreVersionIdentifier()` will instead always send a `*` which acts as a wildcard to match all ETags.
- All operations allow for adding custom headers via `withCustomHeaders(...)`


#### Handling of ETags

An [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) is a version identifier which is often used to implement an optimistic locking mechanism. The SAP Cloud SDK will try to read version identifiers from responses and set them when sending OData requests.

Consider the following example:

```ts
async function modifyBusinessPartner(id) {
  const destination = { url: 'https://my.s4-system.com' };
  
  const partner = await BusinessPartner.requestBuilder()
      .getByKey(id)
      .execute(destination);
      
  // do some modification
  applyModification(partner);
  
  return BusinessPartner.requestBuilder()
      .update(partner)
      .execute(destination);
}
```

When executing `getAll` and `getByKey` requests the SAP Cloud SDK will automatically attempt to extract the version identifier from the response and store it within the returned entity (`partner` in the example above). When executing `update` requests the version identifier will be sent in the `If-match` request header.

:::note
If a service requires this header to be sent: Fetching the entity from the service first is essential to ensure that the ETag is present and up to date.
:::

#### Handling of CSRF tokens

For create, update and delete requests the SDK will try to send a [CSRF token](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-header_token). Upon execution the request will try to fetch a token first before issuing the actual create request. Many services require this behavior for security reasons. However, the create request will be made without a CSRF token if none could be obtained.

### Select

When reading entities the API offers `select( ... )` on the builders. Through it the query parameters `$select` and `$expand` are set. It takes in properties of the entity being queried. Primitive properties are added to `$select` while complex and navigational properties are added to `$expand`. This handling is done automatically by the SDK.

The properties that can be selected or expanded are represented via static fields on the entity class. So there will be a field for each property. E.g. the business partner entity has `BusinessPartner.FIRST_NAME` as representation of a property and `BusinessPartner.TO_BUSINESS_PARTNER_ADDRESS ` as representation of a navigation property.


```ts
BusinessPartner.requestBuilder()
    .getAll()
    .select(
        BusinessPartner.FIRST_NAME,
        BusinessPartner.LAST_NAME,
        BusinessPartner.TO_BUSINESS_PARTNER_ADDRESS
    )
    .execute(destination);
```

The above translates to the following query parameters:

```sql
$select=FirstName,LastName&$expand=to_BusinessPartnerAddress
```

One can also apply select again to the expanded object:

```ts
BusinessPartner.requestBuilder()
    .getAll()
    .select(
        BusinessPartner.FIRST_NAME,
        BusinessPartner.TO_BUSINESS_PARTNER_ADDRESS.select(
            BusinessPartnerAddress.ADDRESS_ID,
            BusinessPartnerAddress.CITY_CODE
        )
    )
    .execute(destination);
```

The above translates to the following `expand` query parameters:

```sql
$select=FirstName,to_BusinessPartnerAddress/AddressID,to_BusinessPartnerAddress/CityCode&$expand=to_BusinessPartnerAddress
```

### Filter

When operating on a collection of entities the API offers `filter( ... )` on the builders. It directly corresponds to the `$filter` parameter of the request. Filters are also build via the static property fields on entities.

The following example:

```ts
/*
Get all business partners that either:
  - Have first name 'Alice' but not last name 'Bob'
  - Or have first name 'Mallory'
*/
BusinessPartner.requestBuilder()
    .getAll()
    .filter(
        or(
            and(
                BusinessPartner.FIRST_NAME.equals('Alice'),
                BusinessPartner.LAST_NAME.notEquals('Bob')
            ),
            BusinessPartner.FIRST_NAME.equals('Mallory')
        )
    )
    .execute({
        url: '<yourURL>'
    });
```

Will translate to this filter parameter:
```sql
$filter=(((FirstName eq 'Alice') and (LastName ne 'Bob')) or (FirstName eq 'Mallory'))
```

Take note of the order of `and` and `or`. As `or` is invoked on the result of `and` it will form the outer expression while `and` is an inner expression in the first branch of `or`.

To achieve a different order with `and` as the top level statement one would nest the `or` within `and(...)`:

```ts
and(
    or(
        BusinessPartner.FIRST_NAME.equals('Alice'),
        BusinessPartner.LAST_NAME.notEquals('Bob')
    ),
    BusinessPartner.FIRST_NAME.equals('Mallory')
)
```

#### Available Filter Expressions

<!-- TODO: Explain filters on complex types and navigational properties -->

The [OData v4 standard](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_SystemQueryOptionfilter) allows for a wide range of filter expressions. A detailed list of what is available in the SDK can be obtained from [the documention](https://sap.github.io/cloud-sdk/docs/js/api-reference-js-ts/). The functionality can also be discovered through the fluent API.

The below example leverages OData v4 exclusive features to build a more complex request:

```ts
/*
Fetch all business partners where:
- the last name is at least twice as long as the first name
- AND the combined string of first and last name does not contain 'bob'
*/
BusinessPartner.requestBuilder()
    .getAll()
    .filter(
        and(
            filterFunction('multiply', 'int', filterFunction('length', 'int', BusinessPartner.FIRST_NAME), '2')
                .lessThan(BusinessPartner.LAST_NAME.edmType.length)
            ,substringOf(
                filterFunction('concat', 'string', BusinessPartner.FIRST_NAME, BusinessPartner.LAST_NAME._fieldName),
                'bob')
                    .equals(true)
        )
    )
    .execute({
        url: '<yourURL>'
    });
```

### Count

Not yet available.

<!--
### Batch Requests WIP

OData batch requests combine multiple operations into one POST operation, allowing you to execute multiple requests with just one network call. This can significantly reduce the network overhead you have to deal with, when you want to execute a large number of requests.

```ts
async updateAddreses(businessPartnerAddresses: BusinessPartnerAddress[]): Promise<BusinessPartnerAddress[]> {
    const updateRequests = businessPartnerAddresses.map(
        address => BusinessPartnerAddress.requestBuilder().update(address)
    );
    const retrieveRequests = businessPartnerAddresses.map(
        address => BusinessPartnerAddress.requestBuilder().getByKey(address.businessPartner, address.addressId)
    );

    const [updateChangesetResponse, ...retrieveResponses] = await batch(changeset(...updateRequests), ...retrieveRequests)
        .execute({
            url: 'http://localhost:8080'
        });

    return retrieveResponses.reduce((addresses, response: ReadResponse) => [...addresses, ...response.as(BusinessPartnerAddress)], []);
}
```

<!--
### Advanced OData Features ###

Function Imports / Functions & Actions
-->
