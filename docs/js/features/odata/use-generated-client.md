---
id: use-typed-odata-client-for-js
title: Use the type-safe client to consume OData Services for JS/TS
hide_title: false
hide_table_of_contents: false
sidebar_label: Use the type-safe client to consume OData Services for JS/TS
description: Use SAP Cloud SDK for JavaScript to build and run OData requests in a typesafe way.
keywords:
- sap
- cloud
- sdk
- odata
- JavaScript 
- TypeScript
- consume
author: Charles Dubois
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Making a request with the generated OData client

The typed OData client allows to build type-safe OData requests for a given service.
Every OData client generated by the SAP Cloud SDK provides request builders and abstractions for entity sets, that we refer to as entities. In order to create a request towards a specific entity set, leverage the fluent API of an entity.

First, import the generated service:

```ts
import { MyEntity } from './outputDir/my-service';
```

Where `outputDir` is the directory you specified when generating the service and `my-service` was the ` directoryName` specified in the `serviceMapping.json` file which is inside your input directory.

On an abstract level, creating a request using the fluent api always follows the same simple structure:

```ts
return MyEntity.requestBuilder()
    .<requestType>(...)
    .<additionalRequestConfiguration>(...)
    .execute(destination);
```

Every entity has a `requestBuilder` function, that allows to chain all types of request builders that are available for this entity, e. g. `MyEntity.requestBuilder().getAll()` for the [`getAll`](#GetAll) request type.

Potential request types (denoted by `requestType` in the example above) are [`create`](#Create), [`getAll`](#GetAll), [`getByKey`](#getByKey), [`update`](#Update) and [`delete`](#Delete).

:::note
Some entities do not support all of the request types, which in turn won't be available through the API.
:::

The request can further be configured by chaining additional configuration functions (denoted by `additionalRequestConfiguration` in the example above). All requests can be configured by setting [custom request headers](#Setting-custom-request-headers), [custom query parameters](#Setting-custom-query-parameters) and a [custom service path](#Setting-custom-service-path).

Each request type has additional request specific configuration options:

Creating  an entity `asChildOf` another entity for [`create`](#Create) requests, [ETag handling](#Handling-of-ETags) for [`update`](#Update) and [`delete`](#Delete) requests, as well as set operations for [`getAll`](#GetAll) requests and [`select`](#Select)ing properties for [`getAll`](#GetAll) and [`getByKey`](#GetByKey) requests.
<!--
*3 if there was a specific section on create this should rather be explained there and in more detail.
-->

The last step when making a request using the SAP Cloud SDK is the request execution. Once the request is configured, chain the `execute` function and pass a [destination](/cloud-sdk/docs/js/features/connectivity/destination-js-sdk/) to it.

### Setting custom request headers

To use the SAP API Business Hub sandbox for your requests, you will need to pass the `apikey` using the `withCustomHeaders` method. You can also set the `authorization` with this method.

:::caution
Setting `authorization` (and `apikey`) headers will overwrite any automatic authorization header building that the SDK would normally do.
:::

Checkout the following example:

```ts
MyEntity.requestBuilder()
    .getAll()
    .withCustomHeaders({
        apikey: 'my-api-key'
    });
```

### Setting custom query parameters

This method allows you to set key-value pairs in the request
Key-value pairs denoting additional custom query parameters to be set in the request

:::caution
Setting custom query parameters overwrites any other configuration that might have been created by the SDK.
:::

```ts
MyEntity.requestBuilder()
    .getAll()
    .withCustomQueryParameters({
        language: 'en'
    });
```

### Setting a custom service path

Replace the default service path with the given custom path. In case of the S/4HANA APIs, the servicePath defaults to `'/sap/opu/odata/sap/'` and can be overwritten here.

```ts
MyEntity.requestBuilder()
    .getAll()
    .withCustomServicePath('my/custom/service/path');
```

<!--TODO
explain how to get `url` and `relativeUrl` of the request
custom configuration stuff
-->

## OData Features

Below different OData features are documented using the [Business Partner Service](https://api.sap.com/api/API_BUSINESS_PARTNER/resource) on S/4HANA as an example.

### Basic CRUD Operations

OData, as RESTful API protocol, follows the CRUD model: Create, Read, Update, Delete. These models return a builder object that allows for specifying certain request parameters, depending on the operation.

### GetAll

Queries all BusinessPartner entities.

```ts
BusinessPartner.requestBuilder().getAll();
```

#### Select

When reading entities, the API offers `select( ... )` on the builders. Through it, the query parameter `$select` is set. It restricts the response to the given selection of properties in the request.

<!-- OData v4
When reading entities, the API offers `select( ... )` on the builders. Through it, the query parameters `$select` and `$expand` are set. It takes in properties of the entity being queried. Primitive properties are added to `$select` while complex and navigational properties are added to `$expand`. This handling is done automatically by the SDK.
-->

The properties that can be selected or expanded are represented via static fields on the entity class. So there will be a field for each property. E.g. the business partner entity has `BusinessPartner.FIRST_NAME` as representation of a property and `BusinessPartner.TO_BUSINESS_PARTNER_ADDRESS ` as representation of a navigation property.


```ts
BusinessPartner.requestBuilder()
    .getAll()
    .select(
        BusinessPartner.FIRST_NAME,
        BusinessPartner.LAST_NAME,
        BusinessPartner.TO_BUSINESS_PARTNER_ADDRESS
    )
    .execute(destination);
```

The above translates to the following query parameters:

```sql
$select=FirstName,LastName,to_BusinessPartnerAddress
```

<!-- OData v4
```sql
$select=FirstName,LastName&$expand=to_BusinessPartnerAddress
```
-->

One can also select properties of the expanded object:

```ts
BusinessPartner.requestBuilder()
    .getAll()
    .select(
        BusinessPartner.FIRST_NAME,
        BusinessPartner.TO_BUSINESS_PARTNER_ADDRESS.select(
            BusinessPartnerAddress.ADDRESS_ID,
            BusinessPartnerAddress.CITY_CODE
        )
    )
    .execute(destination);
```

The above translates to the following query parameters:

```sql
$select=FirstName,to_BusinessPartnerAddress/AddressID,to_BusinessPartnerAddress/CityCode&$expand=to_BusinessPartnerAddress
```

### Filter

When operating on a collection of entities the API offers `filter( ... )` on the builders. It directly corresponds to the `$filter` parameter of the request. Filters are also build via the static property fields on entities.

The following example:

```ts
/*
Get all business partners that either:
  - Have first name 'Alice' but not last name 'Bob'
  - Or have first name 'Mallory'
*/
BusinessPartner.requestBuilder()
    .getAll()
    .filter(
        or(
            and(
                BusinessPartner.FIRST_NAME.equals('Alice'),
                BusinessPartner.LAST_NAME.notEquals('Bob')
            ),
            BusinessPartner.FIRST_NAME.equals('Mallory')
        )
    )
    .execute(destination);
```

Will translate to this filter parameter:
```sql
$filter=(((FirstName eq 'Alice') and (LastName ne 'Bob')) or (FirstName eq 'Mallory'))
```

Take note of the order of `and` and `or`. As `or` is invoked on the result of `and` it will form the outer expression while `and` is an inner expression in the first branch of `or`.

It's also possible to add multiple filters in the same filter function without using `and`, as they will be concatenated. This example:

```ts
.filter(
    and(
        BusinessPartner.FIRST_NAME.equals('Alice'),
        BusinessPartner.LAST_NAME.notEquals('Bob')
    )
)
```

Can be reduced to this:

```ts
.filter(
    BusinessPartner.FIRST_NAME.equals('Alice'),
    BusinessPartner.LAST_NAME.notEquals('Bob')
)
```

More advanced filter can be found [here](#Available-Filter-Expressions)

#### OrderBy

Add order-by statements to the request.

#### Other Set operations

- `skip` skips a number of entities. Useful for paging.
- `top` limits the number of returned entities.

### GetByKey

Like [GetAll](#GetAll) but it only retrieves one entity based on its key.

```ts
BusinessPartner.requestBuilder().getByKey('id');
```

### Create

```ts
BusinessPartner.requestBuilder().create(partner);
```

You can also create  an entity `asChildOf` another entity.

### Update

```ts
BusinessPartner.requestBuilder().update(partner);
```

`ignoreVersionIdentifier()` Instructs the request to force an overwrite of the entity.
Update allow to modify how [ETags](#Handling-of-ETags) are handled.

### Delete

```ts
//this is only for the example, oyu can't delete a BusinessPartner
BusinessPartner.requestBuilder().update(partner);
```

`ignoreVersionIdentifier()` Instructs the request to force an overwrite of the entity.
`setVersionIdentifier` adds an ETag version identifier in the delete request header.
Delete allow to modify how [ETags](#Handling-of-ETags) are handled.

### Handling of ETags

An [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag) is a version identifier which is often used to implement an optimistic locking mechanism. The SAP Cloud SDK will try to read version identifiers from responses and set them when sending OData requests.

Consider the following example:

```ts
async function modifyBusinessPartner(id) {
    const destination = { url: 'https://my.s4-system.com' };

    const partner = await BusinessPartner.requestBuilder()
        .getByKey(id)
        .execute(myDestination);
        
    // do some modification
    applyModification(partner);

    return BusinessPartner.requestBuilder()
        .update(partner)
        .execute(destination);
}
```

When executing `getAll` and `getByKey` requests the SAP Cloud SDK will automatically attempt to extract the version identifier from the response and store it within the returned entity (`partner` in the example above). When executing `update` requests the version identifier will be sent in the `If-match` request header.

:::note
If a service requires this header to be sent: Fetching the entity from the service first is essential to ensure that the ETag is present and up to date.

By default an ETag is sent if it's present on the entity being modified. `ignoreVersionIdentifier()` will instead always send a `*` which acts as a wildcard to match all ETags.
:::


### Handling of CSRF tokens

For create, update and delete requests the SDK will try to send a [CSRF token](https://en.wikipedia.org/wiki/Cross-site_request_forgery#Cookie-to-header_token). Upon execution the request will try to fetch a token first before issuing the actual create request. Many services require this behavior for security reasons. However, the create request will be made without a CSRF token if none could be obtained.

#### Available Filter Expressions

<!-- TODO: Explain filters on complex types and navigational properties, and update for v4

The [OData v4 standard](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_SystemQueryOptionfilter) allows for a wide range of filter expressions. A detailed list of what is available in the SDK can be obtained from [the documention](https://sap.github.io/cloud-sdk/docs/js/api-reference-js-ts/). The functionality can also be discovered through the fluent API.
-->

There are predefined filter functions e. g. `length`, `substring`, `substringOf` in the core library, that allows for a wide range of filtre expressions:

```ts
/*
Fetch all business partners who have a first name shorter than 5 letters
*/
BusinessPartner.requestBuilder()
    .getAll()
    .filter(length(BusinessPartner.FIRST_NAME).lessThan(5))
    .execute(destination);
```

<!--TODO: construction of additional filter functions

The below example leverages OData v4 exclusive features to build a more complex request:
(to change, might not work)

```ts
//Fetch all business partners where:
//- the last name is at least twice as long as the first name
//- AND the combined string of first and last name does not contain 'bob'
BusinessPartner.requestBuilder()
    .getAll()
    .filter(
        filterFunction('multiply', 'int', length(BusinessPartner.FIRST_NAME), '2')
            .lessThan(length(BusinessPartner.LAST_NAME)),
        substringOf(
            concat(BusinessPartner.FIRST_NAME, BusinessPartner.LAST_NAME),
            'bob'
        )
            .equals(true)
    )
    .execute(destination);
```

### Count

Not yet available.

### Batch Requests WIP

OData batch requests combine multiple operations into one POST operation, allowing you to execute multiple requests with just one network call. This can significantly reduce the network overhead you have to deal with, when you want to execute a large number of requests.

```ts
async updateAddreses(businessPartnerAddresses: BusinessPartnerAddress[]): Promise<BusinessPartnerAddress[]> {
    const updateRequests = businessPartnerAddresses.map(
        address => BusinessPartnerAddress.requestBuilder().update(address)
    );
    const retrieveRequests = businessPartnerAddresses.map(
        address => BusinessPartnerAddress.requestBuilder().getByKey(address.businessPartner, address.addressId)
    );

    const [updateChangesetResponse, ...retrieveResponses] = await batch(changeset(...updateRequests), ...retrieveRequests)
        .execute(destination);

    return retrieveResponses.reduce((addresses, response: ReadResponse) => [...addresses, ...response.as(BusinessPartnerAddress)], []);
}
```

<!--
### Advanced OData Features ###

Function Imports / Functions & Actions
-->
