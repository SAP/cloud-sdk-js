import {
  buildResolveInputGlob,
  resolveGlob,
  resolveOptionsPerService,
  resolvePath,
  resolveRequiredPath
} from './options-parser';
import type { ServiceType } from './options-parser';

function getReadmeText(serviceType: ServiceType): string {
  return serviceType === 'OData'
    ? "When set to true, the generator will write a README.md file into the root folder of every package. The information in the readme are mostly derived from accompanying Swagger or OpenAPI files. Therefore it is recommended to use the 'readme' option in combination with 'useSwagger'."
    : 'Generate default `README.md` files in the client directories.';
}

function getInputText(serviceType: ServiceType): string {
  return serviceType === 'OData'
    ? 'Specify the path to the directory or file containing the OData service definition(s) to generate clients for. Accepts Swagger and EDMX definitions as XML and JSON files. Throws an error if the path does not exist.'
    : 'Specify the path to the directory or file containing the OpenAPI service definition(s) to generate clients for. Accepts Swagger and OpenAPI definitions as YAML and JSON files. Throws an error if the path does not exist.';
}
/**
 * @internal
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function getCommonCliOptions(serviceType: ServiceType) {
  return {
    input: {
      alias: 'i',
      describe: getInputText(serviceType),
      coerce: buildResolveInputGlob(serviceType),
      type: 'string',
      demandOption: true,
      requiresArg: true
    },
    optionsPerService: {
      alias: 's',
      describe:
        'Configuration file to ensure consistent names between multiple generation runs with updated / changed metadata files. The configuration allows to set a `directoryName` and `npmPackageName` for every service, identified by the path to the original file. It also makes sure that names do not change between generator runs. If a directory is passed, a `options-per-service.json` file is read/created in this directory.',
      type: 'string',
      coerce: resolveOptionsPerService
    },
    clearOutputDir: {
      type: 'boolean',
      describe:
        'Remove all files in the output directory before generation. Be cautious when using this option, as it really removes EVERYTHING in the output directory.',
      default: false
    },
    include: {
      type: 'string',
      coerce: resolveGlob,
      describe:
        'Include files matching the given glob into the root of each generated client directory.',
      requiresArg: true
    },
    metadata: {
      describe: 'When set to true, SDK metadata for the API hub is generated.',
      type: 'boolean',
      default: false,
      hidden: true
    },
    outputDir: {
      type: 'string',
      alias: 'o',
      describe:
        'Specify the path to the directory to generate the client(s) in. Each client is generated into a subdirectory within the given output directory. Creates the directory if it does not exist. Customize subdirectory naming through `--optionsPerService`.',
      coerce: resolveRequiredPath,
      demandOption: true,
      requiresArg: true
    },
    overwrite: {
      describe:
        'By default, the generator will exit when encountering a file that already exists. When set to true, it will be overwritten instead. Please note that compared to the --clearOutputDir option, this will not delete outdated files.',
      type: 'boolean',
      default: false
    },
    packageJson: {
      describe:
        'When enabled, a `package.json` that specifies dependencies and scripts for transpilation is generated.',
      type: 'boolean',
      default: false
    },
    prettierConfig: {
      type: 'string',
      alias: 'p',
      describe:
        'Specify the path to the prettier config. If not given a default config will be used for the generated sources.',
      coerce: resolvePath,
      requiresArg: true
    },
    skipValidation: {
      type: 'boolean',
      describe:
        'By default, the generation fails, when there are duplicate or invalid names in the generated services. Set this to true to enable unique and valid name generation. The names will then be generated by appending numbers and prepending prefixes.',
      default: false
    },
    transpile: {
      type: 'boolean',
      alias: 't',
      describe:
        'Transpile the generated TypeScript code. When enabled a default `tsconfig.json` will be generated and used. It emits `.js`, `.js.map`, and `.d.ts` files. To configure transpilation set `--tsconfig`.',
      default: false
    },
    tsconfig: {
      describe:
        'Replace the default `tsconfig.json` by passing a path to a custom config. By default, a `tsconfig.json` is only generated, when transpilation is enabled (`--transpile`). If a directory is passed, a `tsconfig.json` file is read from this directory.',
      type: 'string',
      coerce: resolvePath
    },
    verbose: {
      describe:
        'By default, only errors, warnings and important info logs will be displayed. If set to true, all logs will be displayed.',
      type: 'boolean',
      default: false
    },
    readme: {
      type: 'boolean',
      describe: getReadmeText(serviceType),
      default: false,
      hidden: true
    }
  } as const;
}

/**
 * Generator options shared by the OData and OpenApi generator.
 */
export interface CommonGeneratorOptions {
  /**
   * Specify the path to the directory or file containing the service definition(s) to generate clients for.
   * Throws an error if the path does not exist.
   */
  input: string;
  /**
   * Configuration file to ensure consistent names between multiple generation runs with updated / changed metadata files.
   * The configuration allows to set a `directoryName` and `npmPackageName` for every service, identified by the path to the original file.
   * It also makes sure that names do not change between generator runs.
   * If a directory is passed, a `options-per-service.json` file is read/created in this directory.
   */
  optionsPerService?: string;
  /**
   * Delete EVERYTHING in the specified output directory before generating code.
   */
  clearOutputDir?: boolean;
  /**
   * Include files matching the given glob into the root of each generated client directory.
   */
  include?: string;
  /**
   * Hidden option only for internal usage - generate metadata for API hub integration.
   */
  metadata?: boolean;
  /**
   * Directory to save the generated code in.
   */
  outputDir: string;
  /**
   * Generate a `package.json` file, specifying dependencies and scripts for compiling.
   */
  packageJson?: boolean;

  /**
   * Exit when encountering a file that already exists.
   * When set to true, it will be overwritten instead.
   * Note, that compared to the `clearOutputDir` option, this will not delete outdated files.
   */
  overwrite?: boolean;
  /**
   * By default, only errors, warnings and important info logs will be displayed.
   * If set to true, all logs will be displayed.
   */
  verbose?: boolean;
  /**
   * Generation will stop if objects need renaming due to non-unique conditions or conflicts to JavaScript keywords.
   * If you enable this option, conflicts are resolved by appending postfixes like '_1".
   */
  skipValidation?: boolean;
  /**
   * When enabled, generates transpiled `.js`, `.js.map`, and `.d.ts` files.
   * By default, only `.ts` files are generated.
   */
  transpile?: boolean;
  /**
   * Replace the default `tsconfig.json` by passing a path to a custom configuration.
   * By default, a `tsconfig.json` is only generated when transpilation is enabled (`transpile`).
   * If a directory is passed, a `tsconfig.json` file is read from this directory.
   */
  tsconfig?: string;
  /**
   * Specify the path to the prettier config. If not given a default config will be used for the generated sources.
   */
  prettierConfig?: string;
  /**
   * Generate default `README.md` files in the client directories.
   */
  readme?: boolean;
  /**
   * Generate ECMAScript modules instead of CommonJS modules.
   */
  generateESM?: boolean;
}
