/* Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved. */

import { resolve, extname } from 'path';
import { existsSync, lstatSync } from 'fs';
import { Command, flags } from '@oclif/command';
import { cli } from 'cli-ux';
import { createLogger } from '@sap-cloud-sdk/util';
import { parseOptionsFromConfig } from '../generator-utils';
import { generate, generateWithParsedOptions } from '../generator';

const logger = createLogger('openapi-generator');
class OpenApiGenerator extends Command {
  static description =
    'Generate OpenAPI client(s), that use the connectivity features of the SAP Cloud SDK for JavaScript/TypeScript.';

  static usage = '--input <input> --outputDir <outputDirectory>';
  static examples = [
    `
// generate TypeScript clients from OpenAPI definitions in a directory
$ openapi-generator --input ./my-specs --outputDir ./clients`,
    `
// generate a JavaScript client from a OpenAPI definition file
$ openapi-generator --input ./my-spec.yaml --outputDir ./client --transpile`
  ];

  // eslint-disable-next-line @typescript-eslint/no-var-requires
  static version = require('../../package.json').version;

  static flags
   = {
    input: flags.string({
      char: 'i',
      description:
        'Specify the path to the directory or file containing the OpenAPI service definition(s) to generate clients for. Accepts Swagger and OpenAPI definitions as YAML and JSON files. Throws an error if the path does not exist.',
      parse: input => resolve(input),
      required: false,
      default: '',
      helpValue: '<path/to/input>'
    }),
    outputDir: flags.string({
      char: 'o',
      description:
        'Specify the path to the directory to generate the client(s) in. Each client is generated into a subdirectory within the given output directory. Creates the directory if it does not exist. Customize subdirectory naming through `--optionsPerService`.',
      parse: input => resolve(input),
      required: false,
      default: '',
      helpValue: '<path/to/output>'
    }),
    transpile: flags.boolean({
      char: 't',
      description:
        'Transpile the generated TypeScript code. When enabled a default `tsconfig.json` will be generated and used. It emits `.js`, `.js.map`, `.d.ts` and `.d.ts.map` files. To configure transpilation set `--tsconfig`.',
      default: false
    }),
    include: flags.string({
      description:
        'Include files matching the given glob into the root of each generated client directory.',
      helpValue: '<glob/to/include>'
    }),
    overwrite: flags.boolean({
      description:
        'Allow to overwrite files, that already exist. This is useful, when running the generation regularly.',
      default: false
    }),
    clearOutputDir: flags.boolean({
      description:
        'Remove all files in the output directory before generation. Be cautious when using this option, as it really removes EVERYTHING in the output directory.',
      default: false
    }),
    skipValidation: flags.boolean({
      description:
        'By default, the generation fails, when there are duplicate or invalid names for operations and/or path parameters after transforming them to camel case. Set this to true to enable unique and valid name generation. The names will then be generated by appending numbers and prepending prefixes.',
      default: false
    }),
    tsConfig: flags.string({
      description:
        'Replace the default `tsconfig.json` by passing a path to a custom config. By default, a `tsconfig.json` is only generated, when transpilation is enabled (`--transpile`). If a directory is passed, a `tsconfig.json` file is read from this directory.',
      parse: input => resolve(input),
      helpValue: '<path/to/tsconfig.json>'
    }),
    packageJson: flags.boolean({
      description:
        'When enabled, a `package.json`, that specifies dependencies and scripts for transpilation and documentation generation is generated.',
      default: false
    }),
    verbose: flags.boolean({
      description: 'Turn on verbose logging.',
      default: false
    }),
    optionsPerService: flags.string({
      description:
        'Set the path to a file containing the options per service. The configuration allows to set a `directoryName` and `packageName` for every service, identified by the path to the original file. It also makes sure that names do not change between generator runs. If a directory is passed, a `options-per-service.json` file is read/created in this directory.',
      helpValue: '<path/to/options-per-service.json>',
      parse: input => {
        const isFilePath =
          (existsSync(input) && lstatSync(input).isFile()) || !!extname(input);
        return isFilePath
          ? resolve(input)
          : resolve(input, 'options-per-service.json');
      }
    }),
    packageVersion: flags.string({
      description: 'Set the version in the generated package.json.',
      default: '1.0.0',
      hidden: true
    }),
    readme: flags.boolean({
      description:
        'Generate default `README.md` files in the client directories.',
      default: false,
      hidden: true
    }),
    metadata: flags.boolean({
      description: 'When enabled, metadata for the API hub is generated.',
      default: false,
      hidden: true
    }),
    config: flags.string({
      name: 'config',
      char: 'c',
      description:
        'Set the path to the config.json file for generation.',
      helpValue: '<path/to/config.json>',
      required: false,
    })
  };

  async run(): Promise<void> {
    try {
      const parsed = this.parse(OpenApiGenerator);
      if(parsed.flags.config){
        await generate(parseOptionsFromConfig(parsed.flags.config));
      } else {
        if(parsed.flags.input === '' || parsed.flags.outputDir === ''){
          throw new Error('Either input or outputDir were not set.');
        }
        await generateWithParsedOptions(parsed.flags);
      }
    } catch (err) {
      logger.error(err);
      cli.exit(1);
    }
  }
}

export = OpenApiGenerator;
